{"componentChunkName":"component---src-templates-blog-post-js","path":"/hello-shader","result":{"data":{"markdownRemark":{"html":"<p>I never thought that I'd be doing this but here we are, I'm writing for the web and you're reading me! But let's get right into it without dilly dallying</p>\n<p>This article is the start of a series of articles that I plan on writing about shaders while learning how to write them. Documenting the learning process in this way will hopefully help me understand what areas I have covered, where I feel comfortable, and which parts I should focus on next. I've always been someone who starts something but never really gets around to finishing it, and so I hope that I can finally end that with these articles and have more understanding after, let's say a month, of where I was and where I am headed(looking at you @kayserifserif, thanks for the inspiration!)</p>\n<h2>Aand it's shader time</h2>\n<p>Today I will be going through a shader I wrote to recreate an old sketch made in Processing. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; flex:1;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4cbd230b51032aee94c3a5b4d12b9127/32056/processing-sketch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 106%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADr0lEQVQ4y61U7U/TVxQuff+1UgngQKAUkWjbEKi8iLVkUFqKvDkRUyPxAwl/AF/mjKhsggsKW50vY1+MCIhvkMy6bHMu+7ZI9Jv6wSxZIqlvWbI4N4gmNtzHc0/fxpCYmP2Skzz3d8499zznnueq7HZ7lAxk4m1WV1cvfD6fCAQChOuEw+FYFrPR7hCbSp0iWGVfVOn1eqHT6WAwGKAoCmjNpihG/hfDStL37zi5z2iMxUksTUXfIpkE4n8xjUYjARp89eLK1UkUFlqxerUFk1Pn0LmrQx6Eg4f2Y+jYUcaNAR8uXh5HQUE+LBYLznx9Ets/amNfWloakglPnjohQN+eriA8HreEmJ65DI1Wg5evXiASmWNK58fPsm9bcxPKy8sZ3/jpOidUq9VQUVZOmJmZKSoqKmA2m6HVainYhby8PA6srq6Ey+VinJ+fj5qaGt4sD2hvb4WtqBDxtqUSZmVl0k36QBUj3gJYrQWM5RS4XGWMc3Nz4PN7odaoOWm990NkZ2elEqYoh5hycHcntrg3M5WJyTEOmp29RatFmMwKBgcH2Lejox1VVZWMw9dn4pSph3QKJ5QzNjx8HA6HHTk5H2B09Az8fj8HDg0dpeZ/xVjSPT9+Dhs2lPClhE6EsHfvntSlJCjLKzcqhmTpWq0mReM/ptNpk9hoNCz1Jygf6Nsnnv/1B1WwGQ6nHQsvn2N4ZIiDbt/5FQ9+u8f4k/0f43V0Hlu3boHT6cDf//yJ48OfLx+bgcF+EXk0h7KyclRUuvBw7nf09vZCq9MgHP4WN2/e4B52d3fj0eM5+Bu9KCpah3v37+LU6dAKlElGidJNJmVFymaz6a2YLXEpgSa/uDozRafaaISy0NfXh9a2Fg46MnAYX4SOMa6t9aC/vx/r1xdj1ap0fBkawa64opZQDoVGeGy6unZTH6t5HK6Fp2ku1XjyNIL5hRdczeg3p9m3s3MHD7v8vv/x2nKlpKdbhAwwmWIUmlsCsNmsjG22IpSUlDBeuzYX7dtbWCVSBBJLXS9TCs2e8Df6WHaydK+3DtbCmFLkoNfWupMJ3W53UnqlpaVStqmENG+ccHziLFNuaGigcXASEvj5lx846OmzCCtFb9DjwtQY0/R4PGja1hhT1MTYkh7K91CQU5CERHHxOpGRkSEuXpoQ9PLwG9fT0yM+O/Ip49a2ZhH+bkaQzsWaNdm0Z1oEg53si7NViZXG472MevaaqoxSP6L0lEdpzSax/Jfw0ZMffVectDexOaF1B58YfAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Processing Eye\"\n        title=\"Processing Eye\"\n        src=\"/static/4cbd230b51032aee94c3a5b4d12b9127/e17e5/processing-sketch.png\"\n        srcset=\"/static/4cbd230b51032aee94c3a5b4d12b9127/7e516/processing-sketch.png 100w,\n/static/4cbd230b51032aee94c3a5b4d12b9127/772e8/processing-sketch.png 200w,\n/static/4cbd230b51032aee94c3a5b4d12b9127/e17e5/processing-sketch.png 400w,\n/static/4cbd230b51032aee94c3a5b4d12b9127/0a47e/processing-sketch.png 600w,\n/static/4cbd230b51032aee94c3a5b4d12b9127/32056/processing-sketch.png 602w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The Processing code uses an Eye class and some vector math that I thought was a bit overkill for the idea of the sketch, which is to have two circles, one inside the other, with the inner circle responding to mouse movement, and sort of imitate human eyes üëÄ </p>\n<p>To try out this shader and experiment with your own, it is very simple and easy to use an extension in VSCode, there is hardly any setup required and you'll be able to see the output right inside your editor with changes being reflected as you type them. I have been using <a href=\"https://marketplace.visualstudio.com/items?itemName=circledev.glsl-canvas\">glsl-canvas</a> but there are a few others as well.„ÄÄ</p>\n<p>For our simple purposes we only need to know how to make circles and make them move using glsl. If you haven't already heard of the <a href=\"https://thebookofshaders.com/\">Book of Shaders</a>, leave this simple minded article right now and head over there because I could never be as succint and amazing in explaining the smallest details or big picture ideas about shaders, and the site is just beautiful. :heart: But if you already know a bit about Fragment Shaders, you'll know that we need a <code>main</code> function, some necessary directives and uniforms and a function to make a circle to begin with. The circle function takes as its input a vector describing the coordinate space of the canvas, a vector for the center of the circle in this coordinate space and a radius value. We're drawing the circle based on the distance between each pixel and the center of the circle. So a color value will be calculated for each pixel based on how far it is from the center of the circle. Now, I referred the Book of Shaders <a href=\"https://thebookofshaders.com/05/\">shaping</a> page myself because this part is not always easy to understand and it takes a lot of time and practice to develop the intuition that'll let you write amazing shaping functions in glsl. Bless us all, Mr Miyagi! </p>\n<pre><code class=\"language-c++\">#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat circle(vec2 _st, vec2 _pos, float _radius) {\n    vec2 dist = _pos-_st;\n    dist *= 0.5;\n    float val = smoothstep(_radius-0.01, _radius+0.01, dot(dist,dist)*4.0);\n    return val;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n</code></pre>\n<p>But for now, since we are not using the circle function inside <code>main</code> you should only see red if you run this shader. On with circles, now ‚ö´‚ö™üî¥</p>\n<pre><code class=\"language-c++\">void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    float c = 1.0-circle(fract(st*2.0), vec2(0.5), 0.2);\n\n    gl_FragColor = vec4(vec3(c), 1.0);\n}\n</code></pre>\n<p>You might be wondering what is this <code>fract</code> business we've got going here and so I will try to explain. Inside our shader the coordinate space, i.e. <code>st</code> lies between 0.0 and 1.0 since we are normalizing using the resolution of the screen, <code>u_resolution</code>. <a href=\"https://thebookofshaders.com/glossary/?search=fract\">fract</a> is a glsl function that returns the fractional value of any number. I am using it here to be able to draw more than one circle while only using <code>vec(0.5)</code> as the location for all the circles. The subtraction in the beginning is to reverse the color of circle and background. </p>\n<p>To make the smaller circle within the bigger circle, we'll call the <code>circle</code> function again, giving it the same coordinate space and a smaller radius, but this time the location if going to be a function of <code>u_time</code>. We want the small circle to move in a circle(yay circles!), so using the uniform <code>u_time</code> we calculate the position using the polar coordinate formula for circles and add 0.5 as the offset to center it within the bigger circle.</p>\n<pre><code class=\"language-c++\">void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    float c = 1.0-circle(fract(st*2.0), vec2(0.5), 0.2);\n\n    float smallc_len = 0.25;\n    vec2 smallc_pos = vec2(cos(u_time)*smallc_len, sin(u_time)*smallc_len)+0.5;\n    float smallc = circle(fract(st*2.0), vec2(smallc_pos), 0.1);\n\n    gl_FragColor = vec4(vec3(c*smallc), 1.0);\n}\n</code></pre>\n<p>The only thing remaining now is to add mouse interaction üêÅ since we don't want all the circles looking in the same direction, which is what happens if we use <code>u_time</code> as the angle.\nWe'll first normalise the uniform <code>u_mouse</code> just like we normalised the coordinates. And then make a vector starting from the pixel position pointing towards the mouse</p>\n<pre><code class=\"language-c++\">void main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec2 m = u_mouse/u_resolution.xy;\n\n    vec2 dir = m-st;\n    float dirangle = atan(dir.y, dir.x);\n\n    float c = 1.0-circle(fract(st*4.0), vec2(0.5), 0.2);\n\n    float smallc_len = 0.25;\n    vec2 smallc_pos = vec2(cos(dirangle)*smallc_len, sin(dirangle)*smallc_len)+0.5;\n    float smallc = circle(fract(st*4.0), vec2(smallc_pos), 0.1);\n\n    gl_FragColor = vec4(vec3(c*smallc), 1.0);\n}\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; flex:1;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/335a4fe5b383e68e3665fe84728a5074/90cbd/hero.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADn0lEQVQ4y11VWSivXxT9TJlKKEPmSBRJJFOGwjW8oMyEF1KSSIakkJTkgSLudV9MoZApQ4jImwwPxgciMryQKSXr39ru98v333XirHPOd85ea+39U+zs7NDT04OlpSWkp6dDURSYm5ujpaUFy8vLKCkpEYyjvLwci4uLqK+vh6GhoWDZ2dmYm5tDR0cHrKysoKytrUGN19dXhIeHo729HT8jLy8PhYWFGqypqQkREREabHp6Ggr/2dvbg5OTEzw8PJCQkICrqyvc3t4iODgY0dHRqKysxMbGhlyYmJiI/Px8TExMYHBwEC8vL0hOTkZNTQ3e39+hPD8/48+fP7q0OHjByMiIBhseHsbQ0JBubm9vL7Q0NDToMFKh/Pr1C79//9Yc9vf3R2NjowZzdXVFRkaGBrO0tBRcnf/jVUFOTg5qa2vh6OioW4yLi0N1dTW8vb11mJ+fn6RPKlTM2dkZZWVlQpVgXV1dOlLJHbksLi7WkB0aGorIyEgNlpWVBRcXFzw9PWmEElEeHx/B1AMDA+Xw0dGRbCgtLUVubq5Yhwoy2traZExNTaGzs1Ow7u5uzM7O4uPj4/uDIvcPbi4vL7G9va3BVlZWsLOzo+GUYk5OTuqwgYEBKHV1dTg/P5fnqwuZmZnY39+HtbW1DqPnxsbGNJd4eXnJXnVuY2PzLQp9RE5+bg4LC0NqaqoGc3NzQ1RUFIyNjXWYnp4eAgICYGtr+40VFBTg4eFBuGD5GRkZiQAXFxeCnZ6eipJMcXd3VzCaOSgoSD68uroq2NvbG1JSUqBQEAalDwkJEZXJH6Ovr08Uj42NRX9/v2Dr6+sYHR2VNVYH4/j4GHd3d/IwEeX/AnDx5uZGg21ubkrpsXGopmblXF9fw9TUFBYWFlKeCm9jME21g7BKGBRCX18fqvk/Pz9FCPWSmJgYzMzM6Ob/ikARv1VVVWleRJEqKio0GFNPS0vTYKyun25QfH19xUsHBwfS7wg6ODjg79+/ODk5QW9vL0xMTEQAGvrs7Ex6IrnmXpYsOaQ4np6eUNSqaG5ullrlJrYmxvj4OJKSkoQ3lhXj8PAQra2tiI+Pl+bK+Pr6kr90gYhCE6tPNjAwwP39PdjWzMzMdPjW1pYcYkYqxkph0C7kf2FhAYrqLZpbFYW9kFFUVCQX0LxMjRYj16qxySeDXuZcqs3d3R3z8/PyAlYHF/jbwI/yRnLFCmFD9fHxEa7UD3CwnfEsHcH5f+nxpIPX2YsZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Final result\"\n        title=\"Final result\"\n        src=\"/static/335a4fe5b383e68e3665fe84728a5074/e17e5/hero.png\"\n        srcset=\"/static/335a4fe5b383e68e3665fe84728a5074/7e516/hero.png 100w,\n/static/335a4fe5b383e68e3665fe84728a5074/772e8/hero.png 200w,\n/static/335a4fe5b383e68e3665fe84728a5074/e17e5/hero.png 400w,\n/static/335a4fe5b383e68e3665fe84728a5074/0a47e/hero.png 600w,\n/static/335a4fe5b383e68e3665fe84728a5074/90cbd/hero.png 605w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","frontmatter":{"title":"Hello Shader!","date":"February, 19, 2021","path":"hello-shader","tags":["shader","2021"],"excerpt":""}}},"pageContext":{"pathSlug":"hello-shader","prev":null,"next":null}},"staticQueryHashes":["3649515864"]}